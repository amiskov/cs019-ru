# Лекция 3
[Wed 9_12_18](https://brown.hosted.panopto.com/Panopto/Pages/Viewer.aspx?id=fb68ebe9-aaff-4398-a27a-a9590157d419)

Сегодня про сортировку. На примере списка чисел от меньшего к большему.

Использовать будем только то, что знакомо.

Написали примеры списков до и после сортировки.

Потом написали шаблон.

> Template purpose: extract as much code as we can from data definition even if we don't know exactly what problem we're going to solve.


```pyret
data LoN:
    | empty => ...
    | link(f, r) => ...
end

fun lon-fn(l :: List<Number>) -> ...:
    cases(List) l:
        | empty => ...
        | link(f, r) =>
            ...f...
            ...lon-fn(r)...
    end
end
```

Прелесть составления шаблона в том, что мы получаем код без раздумий, просто анализируя определение типа данных. И этот код частично или полностью может быть использован при составлении любой функции, которая работает со списком чисел.

Это работает везде: определение данных рулит процессом их обработки. Это центральная идея ООП. You drive the structure of the program from the structure of the data. Идея одинаковая, разные реализации в ООП-языках и функциональных языках.

Шаблон дает инвентарь. Если задача — получить список и тупо вернуть `3`, то вообще `cases` не нужны. Если задача — посчитать количество элементов, то во втором кейсе значение `f` не важно, вместо него будет всегда `1`. Но шаблон показывает нам то, что у нас есть в арсенале сразу, исходя из определения данных.

Сортировке в `lon-sort.arr` — пример структурной рекурсии (structural recursion). Само определение данных (списка) говорит, на чем надо запускать рекурсию (rest). Структурная рекурсия _гарантированно завершится_.

Структура данных (список) конструируется из тех же составных частей, на которые мы его разбиваем в шаблоне. Мы программируем _индуктивно_, как в математике доказывают по индукции. Индуктивная структура данных — индуктивное программирование.

В аннотации типов можно использовать предикаты, чтобы показать, например, что `List<Number>` должен быть отсортирован. Записывается через `%`: `List<Number>%(is-sorted)`.

См. примеры с созданным типом `NEList` и аналог с предикатом для типа в `max.arr`.



