# Sets
Set в Pyret:

```pyret
[set: 1, 2, 3]
```

Два существенных отличия множеств (sets) от списков:

- в списке элементы расположены в определённом порядке, в сете — нет;
- в сете не может быть повторений: `[set: 1, 2, 3]` такой же, как `[set: 1, 2, 3, 1]`.

Шрирам про то, что в математике всё просто, а в программировании не очень, но оно тоже проникает в математику и вообще везде:

> Software eats everything and makes everybody's life worse. No math is gonna suck as much as software pretty soon.

Примеры коллекций данных, где порядок не важен: список покупок (не надо покупать молоко 2 раза, надо подойти и купить его 1 раз сколько надо).

Множества гораздо более фундаментальные, чем списки или массивы.

Примеры операций над множествами:

- insert :: `T, Set<T> -> Set<T>`
- union :: `Set<T>, Set<T> -> Set<T>`
- is-in :: `T, Set<T> -> Boolean`
- size :: `Set<T> -> Number`
- ...

Задача 1 в классе: implement sets using lists на примере функции `size`.

size может выдавать размер списка, который может быть уже без повторений:

```pyret
fun size1(l):
    l.length()
end
```

size может принимать любой список, удалять из него повторения и уже потом возвращать результат:

```pyret
fun size2(l):
    unique(l).length() # weed out non unique elements before counting
end
```

Задача 2: напишите функцию insert, которая работает также с сэтами через списки.

```pyret
# считаем, что size будет отвечать за повторения
insert = link # по сути добавляем в начало списка элемент

# вставляем только если такого элемента в списке ещё нет
fun insert(el, l):
    if l.member(el):
        l
    else:
        link(el, l)
    end
end
```

Нужно принимать решения о структурах данных (типах) и функциях, которые их используют. Это иллюстрация того, с чем всегда приходится сталкиваться.

## Representation Invariant
Invariant is a thing that is always true.

- size1 полагается на инвариант в структуре данных `Set`. `insert` и `union`, формирующие нове сеты, должны выполнять проверку и возвращать только списки с уникальными элементами.
- `size2` не полагается на то, что список уникальный. Поэтому `insert` и `union` могут ничего не проверять, а просто возвращать список с добавленным элементом или объединённый список. Здесь нет инварианта.

Эти подходы имеют разные big-O complexity. Продолжим рассматривать `insert` и `size`.

TODO: прочитать growing complexity, разобрать big-o и пересмотреть.